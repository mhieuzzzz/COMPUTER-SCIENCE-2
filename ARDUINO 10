#include <Servo.h>
#include <SPI.h>
#include <MFRC522.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// Cảm biến
#define ONE_WIRE_BUS 2   // DS18B20
#define IR_SLOT1 5
#define IR_SLOT2 A0
#define IR_SLOT3 A1
#define SS_PIN 10
#define RST_PIN 9
// Trang tri
#define LED_PIN 3 


Servo servoIn;
Servo servoOut;
LiquidCrystal_I2C lcd(0x27, 16, 2);
MFRC522 rfid(SS_PIN, RST_PIN);

// DS18B20
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

int totalSlots = 3;       // tổng số chỗ
int currentSlots = 3;     // chỗ còn lại
int servoOpen = 180;       // góc mở barie
int servoClose = 90;       // góc đóng barie

String lastCardUID = "";  // Lưu UID thẻ cuối cùng
bool carExiting = false;  // Trạng thái xe đang ra

// Biến điều khiển LED nhấp nháy
bool isBlinking = false;
unsigned long lastBlinkTime = 0;
int blinkInterval = 500; // 500ms (0.5 giây)
bool ledBlinkState = false;

void setup() {
  Serial.begin(9600);
  SPI.begin();
  rfid.PCD_Init();
  
  
  pinMode(IR_SLOT1, INPUT);
  pinMode(IR_SLOT2, INPUT);
  pinMode(IR_SLOT3, INPUT);
  pinMode(LED_PIN, OUTPUT);

  servoIn.attach(6);
  servoOut.attach(7);
  servoIn.write(90);
  servoOut.write(90);
  
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print(" HKN Smart Project");
  lcd.setCursor(0, 1);
  lcd.print("Initializing...");
  
  sensors.begin(); // DS18B20
  delay(2000); // Chờ cảm biến ổn định
  lcd.clear();
}

void loop() {
  // Xử lý nhấp nháy LED (không dùng delay)
  if (isBlinking) {
    unsigned long currentTime = millis();
    if (currentTime - lastBlinkTime >= blinkInterval) {
      lastBlinkTime = currentTime;
      ledBlinkState = !ledBlinkState;
      digitalWrite(LED_PIN, ledBlinkState ? HIGH : LOW);
    }
  }
  
  // Kiểm tra lệnh từ Python
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    
    if (command == "OPEN_IN") {
      lcd.clear();
      lcd.print("Manual Open IN");
      servoIn.write(servoOpen);
      delay(3000);
      servoIn.write(servoClose);
      lcd.clear();
      Serial.println("OPENED_IN");
    }
    else if (command == "OPEN_OUT") {
      lcd.clear();
      lcd.print("Manual Open OUT");
      servoOut.write(servoOpen);
      delay(3000);
      servoOut.write(servoClose);
      lcd.clear();
      Serial.println("OPENED_OUT");
    }
    // Bật led
    else if (command == "LED_ON") {
      isBlinking = false; // Tắt chế độ nhấp nháy
      digitalWrite(LED_PIN, HIGH);
      Serial.println("LED is ON");
    }
    // Tắt led
    else if (command == "LED_OFF") {
      isBlinking = false; // Tắt chế độ nhấp nháy
      digitalWrite(LED_PIN, LOW);
      Serial.println("LED is OFF");
    }
    // Nhấp nháy LED
    else if (command == "LED_BLINK") {
      isBlinking = true;
      lastBlinkTime = millis();
      Serial.println("LED is BLINKING");
    }
    // Dừng nhấp nháy LED (tùy chọn)
    else if (command == "LED_STOP_BLINK") {
      isBlinking = false;
      digitalWrite(LED_PIN, LOW);
      Serial.println("LED BLINK STOPPED");
    }
  }
  
  // Đọc nhiệt độ và trả giá trị về theo dạng float
  sensors.requestTemperatures();
  float tempDS = sensors.getTempCByIndex(0);
  
  // cập nhật slot hiện tại
  currentSlots = 0;
  if (digitalRead(IR_SLOT1) == HIGH) currentSlots++;
  if (digitalRead(IR_SLOT2) == HIGH) currentSlots++;
  if (digitalRead(IR_SLOT3) == HIGH) currentSlots++;
  
  // Hiển thị Nhiệt độ và slot lên lcd
  lcd.setCursor(0, 0);
  lcd.print("Temp:");
  lcd.print(tempDS, 1);
  lcd.print("C   ");
  
  lcd.setCursor(0, 1);
  lcd.print("Slots:");
  lcd.print(currentSlots);
  lcd.print("/");
  lcd.print(totalSlots);
  lcd.print("   ");
  
  // Gửi dữ liệu qua Serial cho Python
  Serial.print("DS18B20 Temp: ");
  Serial.print(tempDS);
  Serial.print("C | Slots: ");
  Serial.print(currentSlots);
  Serial.print("/");
  Serial.println(totalSlots);
  
  // Kiểm tra thẻ RFID
  if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
    // Đọc UID và chuyển thành chuỗi HEX
    String cardUID = "";
    for (byte i = 0; i < rfid.uid.size; i++) {
      if (rfid.uid.uidByte[i] < 0x10) cardUID += "0";
      cardUID += String(rfid.uid.uidByte[i], HEX);
      if (i < rfid.uid.size - 1) cardUID += " ";
    }
    cardUID.toUpperCase();
    
    // Chỉ xử lý nếu là thẻ mới (tránh đọc lặp)
    if (cardUID != lastCardUID) {
      lastCardUID = cardUID;
      
      // Hiển thị UID lên LCD
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Card UID:");
      lcd.setCursor(0, 1);
      lcd.print(cardUID);
      
      // Gửi UID qua Serial cho Python
      Serial.print("Card UID: ");
      Serial.println(cardUID);
      
      // Dừng thẻ hiện tại
      rfid.PICC_HaltA();
      rfid.PCD_StopCrypto1();
      
      // Chờ phản hồi từ Python (timeout 3 giây)
      String response = waitForResponse(3000);
      
      if (response == "VALID") {
        // Thẻ hợp lệ - mở cổng
        lcd.clear();
        lcd.print("Oke duoc vo roi do");
        lcd.setCursor(0, 1);
        lcd.print("Chao mung nhen");
        
        servoIn.write(180);
        Serial.println("Cua mo oi ne");  // Thông báo cổng VÀO đã mở
        delay(3000);
        servoIn.write(90);
        
      } else if (response == "INVALID") {
        // Thẻ không hợp lệ
        lcd.clear();
        lcd.print("Ai cho ma vo ?");
        lcd.setCursor(0, 1);
        
      } else {
        // Không nhận được phản hồi (Python chưa kết nối)
        lcd.clear();
        lcd.print("Loi he thong roi kia");
        lcd.setCursor(0, 1);
        lcd.print("Khong ket noi duoc");
        delay(2000);
      }
      
      lcd.clear();
    }
    
    // Reset sau 5 giây không quét thẻ
  } else {
    if (lastCardUID != "" && millis() % 5000 < 500) {
      lastCardUID = "";
    }
  }
  
  delay(500);
}

// Hàm đợi phản hồi từ Python
String waitForResponse(unsigned long timeout) {
  unsigned long startTime = millis();
  String response = "";
  
  while (millis() - startTime < timeout) {
    if (Serial.available() > 0) {
      response = Serial.readStringUntil('\n');
      response.trim();
      return response;
    }
    delay(10);
  }
  
  return ""; // Timeout
}
